---
title: "A Short Introduction to Algebraic Taxonomy on Genes Regions"
author: 
    - name: Robersy Sanchez
      affiliation: Department of Biology.
                   Pennsylvania State University, University Park, PA 16802
      email: rus547@psu.edu
date: "`r format(Sys.time(), '%d %B %Y')`"
fontsize: 11pt
fontfamily: "serif"
output:
    BiocStyle::html_document:
        toc: true
        toc_depth: 3
        toc_float: 
                collapsed: false
                smooth_scroll: true
        number_sections: true
        theme: united 
        geometry: margin=0.8in
        highlight: tango
toc_float: true
toc_depth: 3
abstract: |
    Herein, we show a short and simply introduction to algebraic taxonomy of 
    genomic/genes regions based on the nalysis of DNA mutational events on DNA 
    Multiple Sequence Alignment (MSA) by means of automorphisms between 
    pairwise DNA sequences algebraically represented as Abelian finite group.
vignette: >
    %\VignetteIndexEntry{Get started-with Methyl-IT}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::knitr}
---
    
<style type="text/css">

div.main-container {
  max-width: 2200px !important;
  padding: 2px;
}

.main-container {
  max-width: 2200px !important;
  padding: 2px;
}

.watch-out {
  max-width: 2200px !important;
  margin-left: auto;
  margin-right: auto;
  background-color: #c9feed;
  font-weight: bold
  font-size: 100%;
  padding: 2px;
}

pre, code {
  max-width: 2200px !important;
  margin-left: auto;
  margin-right: auto;
  background-color: #c9feed;
  font-weight: bold
  font-size: 100px;
  padding: 2px;
}

code {
    font-size: 100%;
    font-family: Consolas,Monaco,"Courier New",monospace;
    border-radius: 0;
}

body {
  max-width: 2200px !important;
  margin: auto;
}  

code.r{
  font-size: 100%;
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
    class.source = "watch-out",
    collapse = TRUE,
    comment = "#>"
)
```


```{r set-options, echo=FALSE, cache=FALSE}
options(width = 120)
```

# Overview
This is a R package to compute the autimorphisms between pairwise aligned DNA
sequences represented as elements from a Genomic Abelian group as described in
reference ([1](#1)). In a general scenario, whole chromosomes or genomic regions
from a population (from any species or close related species) can be
algebraically represented as a direct sum of cyclic groups or more specifically
Abelian *p*-groups. Basically, we propose the representation of multiple
sequence alignments (MSA) of length _N_ as a finite Abelian group created by the
direct sum of Abelian group of _prime-power order_:


$$
\qquad G = (\mathbb{Z}_{p^{\alpha_{1}}_1})^{n_1} \oplus (\mathbb{Z}_{p^{\alpha_{2}}_1})^{n_2} \oplus \dots \oplus (\mathbb{Z}_{p^{\alpha_{k}}_k})^{n_k} 
$$

Where, the $p_i$'s are prime numbers, $\alpha_i \in \mathbb{N}$ and 
$\mathbb{Z}_{p^{\alpha_{i}}_i}$ is the group of integer modulo 
$p^{\alpha_{i}}_i$. 

For the purpose of estimating the automorphism between two aligned DNA
sequences, $p^{\alpha_{i}}_i \in \{5, 2^6, 5^3 \}$.

## Automorphisms

Herein, automorphisms are considered algebraic descriptions of mutational event
observed in codon sequences represented on different Abelian groups. In
particular, as described in references ([3-4](#3)), for each representation of
the codon set on a defined Abelian group there are 24 possible isomorphic
Abelian groups. These Abelian groups can be labeled based on the DNA base-order
used to generate them. The set of 24 Abelian groups can be described as a group
isomorphic to the symmetric group of degree four ($S_4$, see reference
([4](#4))).

For further support about the symmetric group on the 24 Abelian group of 
genetic-code cubes, users can also see [Symmetric Group of the Genetic-Code Cubes.](https://github.com/genomaths/GenomeAlgebra_SymmetricGroup), 
specifically the Mathematica notebook 
_IntroductionToZ5GeneticCodeVectorSpace.nb_ and interact with it using
Wolfram Player, freely available (for Windows and Linux OS) at,
<https://www.wolfram.com/player/>.


# Automorphisms on $\mathbb{Z}_{64}$

First, we proceed to load or install, if needed, the R packages required for our
analysis. If needed the R package required for the current analysis can be
installed as:

```{r inst1, eval=FALSE}
install.packages(c("party", "partykit", "data.table", "ggplot2",
                   "ggparty", "dplyr"), dependencies=TRUE)
```

In particular, you might require to install the library 
[CHAID](https://r-forge.r-project.org/R/?group_id=343) can be installed typing 
in R console: 
```{r inst2, eval=FALSE}
install.packages("CHAID", repos="http://R-Forge.R-project.org")
```

You can install GenomAutomorphism package from GitHub
```{r inst3, eval=FALSE}
devtools::install_git("https://github.com/genomaths/GenomAutomorphism.git")
```

If all the required libraries all installed, then we proceed to load the 
libraries
```{r library,warning=FALSE,message=FALSE}
library(GenomAutomorphism)
library(Biostrings)
library(party)
library(partykit)
library(data.table)
library(ggplot2)
library(ggparty)
library(dplyr)
library(CHAID)

```

Next, we proceed to check the DNA multiple sequence alignment (MSA) file. This
is a FASTA file carrying the MSA of primate BRCA1 DNA repair gene. Notice that
we are familiar with the _FASTA_ file, then it is better to directly read it
with function automorphisms. However, for the current example, this step can be
bypassed, since the MSA is provided provided together with _*GenomAutomorphism*_
R package

```{r fasta, message=FALSE, eval = FALSE}
## Do not run it. This is included with package
URL <- paste0("https://github.com/genomaths/seqalignments/raw/master/BRCA1/",
              "brca1_primates_dna_repair_20_sequences.fasta")

brca1_aln <- readDNAMultipleAlignment(filepath = URL)
```

Load MSA available in the package
```{r dat}
data("brca1_aln", package = "GenomAutomorphism")
brca1_aln
```

The sequence names
```{r names}
strtrim(names(brca1_aln@unmasked), 100)
```

Next, function [automorphisms](https://genomaths.github.io/genomautomorphism/reference/automorphism.html) will be applied to represent the codon sequence in
the Abelian group $\mathbb{Z}_{64}$ (i.e., the set of integers remainder modulo
64). The codon coordinates are requested on the cube ACGT. Following reference
([4](#4))), cubes are labeled based on the order of DNA bases used to define the
sum operation.

In Z64, automorphisms are described as functions $f(x) = k\,x \quad mod\,64$,
where $k$ and $x$ are elements from the set of integers modulo 64. Below, in
function [automorphisms](https://genomaths.github.io/genomautomorphism/reference/automorphism.html) three important arguments are given values: _group =
"Z64"_, _cube = c("ACGT", "TGCA")_, and _cube_alt = c("CATG", "GTAC")_. Setting
for group specifies on which group the automorphisms will be computed. These
groups can be: "Z5", "Z64", "Z125", and "Z5^3".

In groups "Z64" and "Z125" not all the mutational events can be described as
automorphisms from a given cube. So, a character string denoting pairs of "dual"
the genetic-code cubes, as given in references ([1-4](#2))), is given as
argument for _cube_. That is, the base pairs from the given cubes must be
complementary each other. Such a cube pair are call dual cubes and, as shown in
reference ([4](#4))), each pair integrates group. If automorphisms are not found
in first set of dual cubes, then the algorithm search for automorphisms in a
alternative set of dual cubes.


```{r url, message=FALSE, eval = FALSE}
## Do not run it. This is included with package

nams <- c("human_1","human_2","gorilla_1","gorilla_2","gorilla_3",
        "chimpanzee_1","chimpanzee_2","chimpanzee_3","chimpanzee_4",
        "bonobos_1","bonobos_2","bonobos_3","bonobos_4","silvery_gibbon_1",
        "silvery_gibbon_1","silvery_gibbon_3","golden_monkey_1",
        "golden_monkey_2","gelada_baboon","bolivian_monkey")

brca1_autm <- automorphisms(
                      seqs = brca1_aln, 
                      group = "Z64", 
                      cube = c("ACGT", "TGCA"),
                      cube_alt = c("CATG", "GTAC"),
                      nms = nams, 
                      verbose = FALSE)
```


Object *brca1_autm* is included with package and can be load typing:
```{r brca1_autm}
data(brca1_autm, package = "GenomAutomorphism")
brca1_autm
```

## Grouping automorphisms by automorphism's coefficients
Automorphisms with the same automorphism's coefficients can be grouped. This
task can be accomplished with function [automorphism_bycoef](https://genomaths.github.io/genomautomorphism/reference/automorphism_bycoef.html). 
However, for the sake of time, its output is included in the package

```{r autby, eval = FALSE}
## Not need to run it here
autby_coef <- automorphism_bycoef(x = brca1_autm,
                                 verbose = FALSE)
```


Object *brca1_autm* is included with package and can be load typing:
```{r brca1_autm2}
data(autby_coef, package = "GenomAutomorphism")
autby_coef
```


In the next we are interested on mutational events in respect to human (as 
reference).
```{r h}
nams <- names(brca1_autm)
idx1 <- grep("human_1.", nams)
idx2 <- grep("human_2.", nams)
idx <- union(idx1, idx2)
h_brca1_autm <- unlist(brca1_autm[ idx ])
h_brca1_autm = h_brca1_autm[ which(h_brca1_autm$autm != 1) ]
h_brca1_autm
```


## Bar plot automorphism distribution by coefficient
The automorphism distribution by cubes can be summarized in the bar-plot graphic.

Object *autby_coef* carried all the pairwise comparisons, while it will be
enough to use data from a single species as reference, e.g., humans.

First the data must be reordered into a \code{\link[base]{data.frame}} object:
```{r dat1}
h_autby_coef <- automorphism_bycoef(x = h_brca1_autm)
h_autby_coef
```


Every single base mutational event across the MSA was classified according IUPAC
nomenclature: 1) According to the number of hydrogen bonds (on DNA/RNA
double helix): strong S={C, G} (three hydrogen bonds) and weak W={A, U} (two
hydrogen bonds). According to the chemical type: purines R={A, G} and
pyrimidines Y={C, U}. 3). According to the presence of amino or keto groups on
the base rings: amino M={C, A} and keto K={G, T}.  Constant (hold) base
positions were labeled with letter H. So, codon positions labeled as HKH means
that the first and third bases remains constant and mutational events between
bases G and T were found in the MSA.

```{r rm-h}

nams <- names(h_autby_coef)
nams <- sub("human[_][1-2][.]", "", nams)
nams <- sub("[_][1-6]", "", nams)

dt <- data.frame(h_autby_coef, species = nams)
dt <- data.frame(dt, species = nams)
dt <- dt[, c("start", "autm", "species", "mut_type", "cube")]
DataFrame(dt)
```


Nominal variables are transformed into \code{\link[base]{factor}}
```{r as.factor}
dt$start <- as.numeric(dt$start)
dt$autm <- as.numeric(dt$autm)
dt$cube <- as.factor(dt$cube)
dt$species <- as.factor(dt$species)
dt$mut_type <- as.factor(dt$mut_type)
```


```{r barplot, fig.height = 5, fig.width = 5}
counts <- table(dt$cube)

par(family = "serif", cex = 0.6, font = 2, mar=c(4,6,4,4))
barplot(counts, #main="Automorphism distribution",
        xlab="Genetic-code cube representation",
        ylab="Fixed mutational events",
        col=c("darkblue","red", "darkgreen", "magenta", "orange"), 
        border = NA, axes = F, #ylim = c(0, 6000),
        cex.lab = 2, cex.main = 1.5, cex.names = 2)
axis(2, at = c(0, 200, 400, 600, 800, 1000), cex.axis = 1.5)
mtext(side = 1,line = -2.8, at = c(0.7, 1.9, 3.1, 4.3),
      text = paste0( counts ), cex = 1.4,
      col = c("white", "red","yellow", "black"))

```


## Classification Tree Chi-squared Automated Interaction Detection (CHAID)

The current CHAID implementation only accepts nominal or ordinal categorical
predictors. When predictors are continuous, they have to be transformed into
ordinal predictors before using the following algorithm. We create a ordinal 
variable *autms* from variable *autm*. [CHAID](install.packages("CHAID", repos="http://R-Forge.R-project.org")) can be download at: <install.packages("CHAID", repos="http://R-Forge.R-project.org")>



```{r datos}
interval <- function(x, a, b) {
    x >= a & x <= b
}

datos = dt
datos$autms <- case_when(datos$autm < 16 ~ 'A1',
                  interval(datos$autm, 16, 31) ~ 'A2',
                  interval(datos$autm, 32, 47) ~ 'A3',
                  datos$autm > 47 ~ 'A4')
datos$autms <- as.factor(datos$autms)

datos$mut_type <- as.character(datos$mut_type)
datos$mut_type[ which(datos$cube == "Trnl") ] <- "indel"
datos$mut_type[ which(datos$cube == "Gaps") ] <- "---"
datos$mut_type <- as.factor(datos$mut_type)

datos$regions <- case_when(datos$start < 230 ~ 'R0',
                  interval(datos$start, 230, 270) ~ 'R1',
                  interval(datos$start, 271, 305) ~ 'R2',
                  interval(datos$start, 306, 338) ~ 'R3',
                  interval(datos$start, 339, 533) ~ 'R4',
                  interval(datos$start, 534, 570) ~ 'R5',
                  interval(datos$start, 571, 653) ~ 'R6',
                  interval(datos$start, 654, 709) ~ 'R7',
                  datos$start > 709 ~ 'R8')

datos$regions <- as.factor(datos$regions)

datos$autm <- as.factor(datos$autm)
datos$species <- as.factor(datos$species)
datos$start <- as.factor(datos$start)
datos$cube <- as.factor(datos$cube)
datos <- datos[, c( "autms", "regions", "mut_type", "cube", "species")]
DataFrame(datos)
```

A classification tree is estimated with CHAID algorithm:
```{r chaid}
ctrl <- chaid_control(minsplit = 200, minprob = 0.8, alpha2 = 0.01, alpha4 = 0.01)
chaid_res <- chaid(species ~ autms + regions + mut_type + cube , data = datos,
                   control = ctrl)
```


### Plotting the CHAID tree
Next, the data must be prepared for plotting the tree with 
[ggparty](https://rdrr.io/cran/ggparty/man/ggparty.html):
```{r, plot-data}
##  Updating CHAID decision tree
dp <- data_party(chaid_res)
dat <- dp[, c("autms", "regions", "mut_type", "cube")]
dat$species <- dp[, "(response)"]
    
    
chaid_tree <- party(node = node_party(chaid_res), 
                    data = dat,
                    fitted =  dp[, c("(fitted)", "(response)")], 
                    names = names(chaid_res))

## Extract p-values
pvals <- unlist(nodeapply(chaid_tree, ids = nodeids(chaid_tree), function(n) {
    pvals <- info_node(n)$adjpvals
    pvals < pvals[ which.min(pvals) ]
    return(pvals)
}))
pvals <- pvals[ pvals < 0.05 ]

## Counts of event per spciees on each node
node.freq <- sapply(seq_along(chaid_tree), function(id) {
    y <- data_party(chaid_tree, id = id)
    y <- y[[ "(response)" ]]
    table(y)
})
## total counts on each
node.size =  colSums(node.freq)
```



Plotting the tree with [ggparty](https://rdrr.io/cran/ggparty/man/ggparty.html) 
(font size adjusted for html output)
```{r chaid-tree, fig.height = 35, fig.width = 55}
ggparty(chaid_tree) +
    geom_edge(aes(color = id, size = node.size[id]/300), show.legend = FALSE) +
    geom_edge_label(size = 14, colour = "red",
                    fontface = "bold", 
                    shift = 0.64, 
                    nudge_x = -0.01,
                    max_length = 10,
                    splitlevels = 1:4) +
    geom_node_label(line_list = list(aes(label = paste0("Node ", id, ": ", splitvar)),
                aes(label = paste0("N=", node.size[id], ", p", 
                                 ifelse(pvals < .001, "<.001",
                                        paste0("=", round(pvals, 3)))), 
                    size = 30)),
                    line_gpar = list(list(size = 30), 
                                     list(size = 30)),
                ids = "inner", fontface = "bold", size = 30) +
    geom_node_info() +
    geom_node_label(aes(label = paste0("N = ", node.size), 
                        fontface = "bold"),
                    ids = "terminal", nudge_y = -0.0, nudge_x = 0.01, size = 12) +
    geom_node_plot(gglist = list(
        geom_bar(aes(x = "", fill = species), size = 0.2, width = 0.9,
                 position = position_fill(), color = "black"),
        theme_minimal(base_family = "arial", base_size = 46),
        scale_fill_manual(values = c("gray50","gray55","gray60",
                                     "gray70","gray80","gray85",
                                     "blue","gray95")),
        xlab(""), 
        ylab("Probability"), 
        geom_text(aes(x = "", group = species, 
                      label = stat(count)),
                  stat = "count", position = position_fill(), 
                  vjust = 1., size = 12)),
        shared_axis_labels = TRUE, size = 1.2) 
```

### Stochastic-deterministic logical rules
Since only one mutational event human-to-human in region R1 from class A3 is 
reported in the right side of the tree, with high probability only non-humans 
hold the following rule: 
```{r rule1}
rule <- (dat$autms == "A4" | (dat$autms == "A3" & dat$mut_type != "HRH"))
unique(as.character(dat[rule,]$species))
```


Only humans-to-human mutations hold the following rule:
```{r rule2}
idx <- dat$autm == "A1" & dat$regions == "R3" & (dat$mut_type == "HHY" | dat$mut_type == "YHH")
dat[ idx, ]
```

Only non-humans hold the following rule
```{r rule3}
rule <- (dat$autms == "A4" | (dat$autms == "A3" & dat$regions != "R1"))
unique(as.character(dat[rule,]$species))
```


A printing version in TIFF format could be:
```{r grh_print, eval=FALSE}
# tiff(filename = "~/home/chaid_tree.tiff",
#      width = 3000, height = 1800, units = "px", pointsize = 1,
#      compression = "lzw", bg = "white", res = 600)
# 
# ggparty(chaid_tree) +
#     geom_edge(aes(color = id), show.legend = FALSE) +
#     geom_edge_label(size = 1, colour = "red", fontface = "bold") +
#     geom_node_label(line_list = list(aes(label = paste0("Node ", id,": ", splitvar)),
#                             aes(label = paste0("N=", node.size[id], ", p",
#                                 ifelse(pvals < .001, "<.001",
#                                      paste0("=", round(pvals, 3)))))),
#                     line_gpar = list(list(size = 4), 
#                                      list(size = 4)),
#                     ids = "inner", label.size = 0.1) +
#     geom_node_info(size = 2) +
#     geom_node_label(aes(label = paste0("N = ", nodesize)),
#                     ids = "terminal", nudge_y = -0.0, 
#                     nudge_x = 0.01, label.size = 0.1,
#                     line_gpar = list(list(size = 3.5), 
#                                      list(size = 3.5))) +
#     geom_node_plot(gglist = list(
#         geom_bar(aes(x = "", fill = species), size = 0.2, width = 10,
#                  position = position_fill(), color = "black"),
#         theme_minimal(base_family = "arial", base_size = 5),
#         scale_fill_manual(values = c("gray50","gray55","gray60",
#                                      "gray70","gray80","gray85",
#                                      "blue","gray95")),
#         xlab(""), 
#         ylab("Probability"), 
#         geom_text(aes(x = "", group = species, 
#                       label = stat(count)),
#                   stat = "count", position = position_fill(), 
#                   vjust = 1., size = 1)),
#         shared_axis_labels = TRUE, size = 1.)
# 
# 
# dev.off()

```



# References
 1.<a name="1"></a> Sanchez R, Morgado E, Grau R. Gene algebra from a genetic
 code algebraic structure. J Math Biol. 2005 Oct;51(4):431-57. doi:
 10.1007/s00285-005-0332-8. Epub 2005 Jul 13. PMID: 16012800. (
 [PDF](https://arxiv.org/pdf/q-bio/0412033.pdf)).
 
 2.<a name="2"></a> Robersy Sanchez, Jesús Barreto (2021) Genomic Abelian Finite
  Groups.
 [doi: 10.1101/2021.06.01.446543](https://doi.org/10.1101/2021.06.01.446543).
 
 3.<a name="3"></a> M. V José, E.R. Morgado, R. Sánchez, T. Govezensky, The 24
 possible algebraic representations of the standard genetic code in six or in
 three dimensions, Adv. Stud. Biol. 4 (2012)
 119–152.[PDF](https://is.gd/na9eap).
 
 4.<a name="4"></a> R. Sanchez. Symmetric Group of the Genetic–Code Cubes.
 Effect of the Genetic–Code Architecture on the Evolutionary Process MATCH
 Commun. Math. Comput. Chem. 79 (2018) 527-560. [PDF](https://bit.ly/2Z9mjM7).

